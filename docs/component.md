# Component

## Concept

Components are the core functionality of the Formotor Component. Each component is a separate container that encapsulates its own business logic.

## Usage

### Global Registration

A global component can be registered via the `Formotor.component(name, options)` method:

```js
Formotor.component('example', {
    // options
});
```

Once the component is registered, it can be used in HTML:

```html
<div fm-app>
    <div fm-component="example"></div>
</div>
```

```js
new Formotor({
    el: '[fm-app]'
});
```

For components that are not registered, Formotor Component automatically uses a blank component as its constructor. You can also register a base component as a constructor for all unregistered components:

```js
Formotor.component('basic', {
    // options of basic component
});
```

### Local Registration

For components that do not require global registration, they can be registered with their parent's `components` option, at which point the component's definition only acts inside the parent component:

```js
new Formotor({
    el: '[fm-app]',
    components: {
        // register example component
        'example': {
            // options
        }
    }
});
```

### Component Options

#### Element

The root component's constructor needs to specify the attached DOM node via the `el` option.

```html
<div fm-app id="app">
    <div fm-component="content"></div>
</div>
```

```js
// register content component
Formotor.component('content', {
    // options, no need to specify the el option
});
// generate a component tree from the specified elements
var comp = new Formotor({
    el: '[fm-app]' // you can also use '#app' or something else
});
```

#### Data

The component's constructor can receive a `data` option as the initial data for the component. It should be noted that if a field in `data` is an object literal, instances of multiple components will share the object. In this case, you should use a function instead of the object literal:

```js
// data.foo is an object literal
var comp = new Formotor({
    el: '[fm-app]',
    data: {
        foo: {
            bar: 1
        },
        greet: 'hello'
    }
});
```

The first alternative, `data.foo` is a function:

```js
var comp = new Formotor({
    el: '[fm-app]',
    data: {
        foo: function() {
            return {
                bar: 1
            };
        },
        greet: 'hello'
    }
});
```

The second alternative, `data` is a function:

```js
var comp = new Formotor({
    el: '[fm-app]',
    data: function() {
        return {
            foo: {
                bar: 1
            },
            greet: 'hello'
        };
    }
});
```

Print the properties generated by `data` in the component, you can get the following results:

```js
console.log(comp.foo['bar']); // 1
console.log(comp.greet); // hello
```

#### Model

With the `data` option, you can also set a special data `model` that will be used as a dependency when calling the component `$set` method. If the child component does not specify `model`, it will automatically inherit the `model` of the parent component.

```js
new Formotor({
    el: '[fm-app]',
    data: {
        model: function() {
            return {
                foo: 1,
                bar: 2
            };
        }
    },
    components: {
        bar: {
            ready: function() {
                console.log(this.model.foo, this.model.bar);
            }
        }
    }
});

// 1 2
```

#### Methods

Similar to `data`, a component can receive a `methods` option and convert it to the instance methods of the component:

```js
var comp = new Formotor({
    el: '[fm-app]',
    methods: {
        greet: function() {
            console.log('Say Hello!');
            this.cheer('Nice Day!');
        },
        cheer: function(msg) {
            console.log(msg);
        }
    }
});

comp.greet();
// Say Hello!
// Nice Day!
```

#### Proxy Events

You can specify the DOM event (via jQuery) that needs to be delegated to the component container via the `proxies` option:

```html
<div fm-app>
    <div fm-component="foo">
        <div class="j-content">Content: Click Here</div>
        <div class="j-content">Another Content: Click Here</div>
        <div class="j-footer" @click="greet($event, 'By Footer!');">Footer: Click Here</div>
        <div class="j-footer">Another Footer: Click Here</div>
    </div>
</div>
```

```js
var comp = new Formotor({
    el: '[fm-app]',
    components: {
        'foo': {
            proxies: {
                'click .j-content': 'greet'
            },
            methods: {
                greet: function(event, msg) {
                    msg = msg || '';
                    console.log('Say Hello!' + msg);
                }
            }
        }
    }
});

// Click `div.j-content` > Say Hello!
// Click `div.j-footer`  > Say Hello!By Footer!
```

As you can see from the above example, the `click` event on `div.j-footer` is also proxy, because when the event is bound by `fm-on:` or `@`, if the element has a class of the specified format (a class that starts with `j-`), then the event is also proxied to the component container through those classes. So the ``click` event of `div.j-footer` is actually listened to by the following way:

```js
comp.$el.on('click', '.j-footer', function(e) {
    comp.greet(e, 'By Footer');
});
```

#### Custom Events

In addition to DOM events, Formotor Component has its own custom event system. You can listen for events via the `events` option, or you can manually listen for events via instance methods:

```js
var comp = new Formotor({
    el: '[fm-app]',
    events: {
        'act:smile': 'smile'
    },
    methods: {
        smile: function(msg) {
            console.log('Smile:', msg);
        },
        cry: function(msg) {
            console.log('Cry:', msg);
        }
    }
});
comp.$on('act:cry', comp.cry);

comp.$trigger('act:smile', '23333'); // Smile: 23333
comp.$trigger('act:cry', '55555'); // Cry: 55555
```

### Communication between Components

Although the Formotor Component components are independent of each other, in actual use, one component may need to synchronize its state according to the state of other components, so there is a need for a mechanism to communicate with each other.

A bad way is to directly change the state of other components in a component or directly call instance methods of other components. This violates the principle of component independence, which leads to the intricate relationship between components and is difficult to maintain. So in Formotor Component, the root component is used to centrally process communication messages between components. The specific way is as follows:

> Assume that component A needs to do the appropriate action based on the state of component B. Then component A listens for an event X on the root component. When the state of B changes, it triggers the event X of the root component, and A performs the corresponding operation in the corresponding callback function.

In actual use, the component responds to the message by listening to the event of the root component through the `$listen` method, and passing the event of the root component through the `$broadcast` method to deliver the message. Here's a simple example:

```html
<div fm-app>
    <div fm-component="foo">
        <input type="text" name="status" @change="updateStatus"/>
    </div>
    <div fm-component="bar">
        <div class="j-status"></div>
    </div>
</div>
```

```js
new Formotor({
    el: '[fm-app]',
    components: {
        'foo': {
            methods: {
                updateStatus: function(e) {
                    this.$broadcast('foo:change', e.target.value);
                }
            }
        },
        'bar': {
            ready: function() {
                this.listen();
            },
            methods: {
                listen: function() {
                    this.$listen('foo:change', this.showStatus);
                },
                showStatus: function(status) {
                    this.$find('.j-status').text(status);
                }
            }
        }
    }
});
```

Running the example shows that when the input value in the component `foo` is changed, it will be displayed in the `div.j-status` of the component `bar`.